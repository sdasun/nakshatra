<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>27 Nakshatra & Zodiac 3D - V7 (Features)</title>
  <style>
    /* ... all your CSS unchanged ... */
    body {
      margin: 0;
      background: #0a0a1a;
      overflow: hidden;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-image: url('/images/sky.png');
      background-blend-mode: overlay;
      background-color: rgba(0, 0, 0, 0.75);
    }

    canvas {
      display: block;
    }

    #controls-container {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      padding: 12px 20px;
      background: rgba(30, 30, 50, 0.85);
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      z-index: 100;
      align-items: center;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    button {
      padding: 8px 12px;
      background: #4a4a7a;
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.2s ease, transform 0.1s ease;
      min-width: 50px;
      text-align: center;
    }

    button:hover {
      background: #5a5a8a;
    }

    button:active {
      background: #3a3a6a;
      transform: scale(0.95);
    }

    button:disabled {
      background: #33334c;
      color: #777799;
      cursor: not-allowed;
    }

    #speedDisplay {
      color: #e0e0ff;
      font-size: 13px;
      min-width: 120px;
      text-align: center;
      padding: 5px;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
    }

    #moon-phase-container {
      position: absolute;
      top: 15px;
      right: 15px;
      padding: 8px;
      background: rgba(30, 30, 50, 0.85);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      color: white;
      min-width: 200px;
      min-height: 250px;
    }

    #moon-phase-image {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      object-fit: cover;
      background-color: #111;
      border: 5px solid rgba(30, 30, 50, 1);
    }

    #moon-phase-name {
      font-size: 21px;
      text-align: center;
      max-width: 150px;
    }
  </style>
</head>

<body>
  <!-- MOON PHASE DISPLAY ELEMENT -->
  <div id="moon-phase-container">
    <canvas id="moon-phase-3d" width="170" height="170"
      style="border-radius: 50%; background: #111; display: block; margin: 0 auto; box-shadow: 0 1px 10px #0006;"></canvas>


    <span id="moon-phase-name">Loading...</span>
  </div>
  <div id="controls-container">
    <div class="control-group">
      <button id="playPauseBtn">Pause</button>
    </div>
    <div class="control-group">
      <button id="reverseBtn" title="Toggle Direction">Forward</button>
    </div>
    <div class="control-group">
      <button id="speedDownBtn" title="Slower">-</button>
      <span id="speedDisplay">Speed: 1s = 1 Day</span>
      <button id="speedUpBtn" title="Faster">+</button>
      <button id="resetSpeedBtn" title="Reset Speed">Reset</button>
    </div>
    <div class="control-group" style="border-left: 1px solid rgba(255,255,255,0.2); padding-left: 10px;">
      <div style="display: flex; flex-direction: column; gap: 8px;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <span style="min-width: 40px; color: #ffcc66;">Sun:</span>
          <span id="sunPositionDisplay"
            style="min-width: 80px; background-color: rgba(0, 0, 0, 0.2); padding: 3px 6px; border-radius: 4px; font-size: 13px;">0°
            0' 0"</span>
          <input type="range" id="sunPositionSlider" min="0" max="360" value="0" style="width: 120px;"
            title="Adjust Sun Position" aria-label="Adjust Sun Position">
          <span id="sunPositionText" style="font-size: 18px; color: #ffcc66; min-width: 150px;"></span>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
          <span style="min-width: 40px; color: #aaccff;">Moon:</span>
          <span id="moonPositionDisplay"
            style="min-width: 80px; background-color: rgba(0, 0, 0, 0.2); padding: 3px 6px; border-radius: 4px; font-size: 13px;">0°
            0' 0"</span>
          <input type="range" id="moonPositionSlider" min="0" max="360" value="0" style="width: 120px;"
            title="Adjust Moon Position" aria-label="Adjust Moon Position">
          <span id="moonPositionText" style="font-size: 18px; color: #aaccff; min-width: 150px;"></span>
        </div>
      </div>
    </div>
  </div>
  <a class="logo" href="https://tharukirana.com" target="_blank"
    style="position: absolute; top: 10px; left: 10px; z-index: 100; display: flex; align-items: center; text-decoration: none; gap: 10px;">
    <img src="/images/tharukirana_logo_small2.png" alt="Tharu Kirana Logo" title="Tharu Kirana Logo"
      style="width: 150px; height: auto; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);">
    <div style="color: #ffffff; font-size: 16px; line-height: 1.4;">
      <strong style="font-size: 18px;">පොහොය නාම කරණ Simulation</strong><br>
      <span style="font-size: 14px;">Developed by Tharu Kirana</span>
    </div>
  </a>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    const { PI, cos, sin, min, max } = Math;

    // ----- MAIN SCENE SETUP -----
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const textureLoader = new THREE.TextureLoader();

    // --- Shared Constants ---
    const NAKSHATRA_COUNT = 27;
    const ZODIAC_COUNT = 12;
    const NAKSHATRA_ARC_RADIANS = (2 * PI) / NAKSHATRA_COUNT;
    const ZODIAC_ARC_RADIANS = (2 * PI) / ZODIAC_COUNT;
    const earthRadius = 2;
    const moonOrbitRadius = earthRadius * 3.5;
    const zodiacInnerRadius = 21;
    const zodiacOuterRadius = 23;
    const nakshatraInnerRadius = 23
    const nakshatraOuterPadaRadius = 24
    const nakshatraOuterRadius = 25
    const sunOrbitRadius = 23;

    // --- Materials ---
    const nakshatraArcMaterial = new THREE.MeshBasicMaterial({ color: 0x555599, side: THREE.DoubleSide, transparent: true, opacity: 0.1 });
    const nakshatraArcMaterialAlt = new THREE.MeshBasicMaterial({ color: 0x6666AA, side: THREE.DoubleSide, transparent: true, opacity: 0.1 });
    const nakshatraDividerMaterial = new THREE.LineBasicMaterial({ color: 0xAAAAFF, linewidth: 2 });

    const zodiacArcMaterial = new THREE.MeshBasicMaterial({ color: 0x998855, side: THREE.DoubleSide, transparent: true, opacity: 0.1 });
    const zodiacArcMaterialAlt = new THREE.MeshBasicMaterial({ color: 0xAA9966, side: THREE.DoubleSide, transparent: true, opacity: 0.1 });
    const zodiacDividerMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFCC, linewidth: 2 });


    // --- Nakshatras ---
    const nakshatras = [
      'අස්විද', 'බෙරණ', 'කැති', 'රෙහෙණ', 'මුවසිරිස', 'අද', 'පුනාවස', 'පුස',
      'අස්ලිය', 'මා', 'පුවපල්', 'උත්‍රපල්', 'හත', 'සිත', 'සා',
      'විසා (වෛශාක්‍ය)', 'අනුර', 'දෙට', 'මුල', 'පුවසල', 'උත්‍රසල',
      'සුවන', 'දෙනට', 'සියාවස', 'පුවපුටුප', 'උත්‍රපුටුප', 'රේවතී'
    ];
    const lunarMonthNames = [
      'වප්', '', 'ඉල්', '', 'උඳුවප්', '', '', 'දුරුතු',
      '', 'නවම්', '', 'මැදින්', '', 'බක්', '',
      'වෙසක්', '', 'පොසොන්', '', 'ඇසල', '',
      'නිකිණි', '', '', 'බිනර', '', ''
    ]
    const nakshatraGroup = new THREE.Group();
    const nakshatraDividersGroup = new THREE.Group();

    nakshatras.forEach((name, i) => {
      const thetaStart = i * NAKSHATRA_ARC_RADIANS;
      const thetaLength = NAKSHATRA_ARC_RADIANS;
      const midAngle = thetaStart + thetaLength / 2;

      // Arc geometry
      const arcGeometry = new THREE.RingGeometry(nakshatraInnerRadius, nakshatraOuterRadius, 3, 1, thetaStart, thetaLength);
      const arcMesh = new THREE.Mesh(arcGeometry, i % 2 === 0 ? nakshatraArcMaterial : nakshatraArcMaterialAlt);
      arcMesh.rotation.x = -Math.PI / 2;
      nakshatraGroup.add(arcMesh);

      // Text sprite (Keeping Nakshatras as sprites for now, simpler)
      const textRadius = nakshatraOuterRadius * 1.04; // Position outside
      const x = textRadius * cos(midAngle);
      const z = textRadius * sin(midAngle);
      const sprite = createTextSprite(name, 24, '#ddddff'); // Existing function
      sprite.position.set(x, 0, z);
      nakshatraGroup.add(sprite);

      // Text plane for lunar month names
      const monthText = lunarMonthNames[i];
      if (monthText.trim() !== '') { // Skip if the text is empty
        const monthSprite = createTextSprite(monthText, 24, '#ffff00'); // New function for text on planes
        // place it under the nakshatra text centered
        monthSprite.position.set(x, 0, z + 1); // Adjust Y position to be below the nakshatra
        // monthSprite.rotation.x = -PI / 2; // Rotate to face the camera
        nakshatraGroup.add(monthSprite);
      }


      // Divider Line
      const points = [];
      const innerPoint = new THREE.Vector3(nakshatraInnerRadius * cos(thetaStart), 0, nakshatraInnerRadius * sin(thetaStart));
      const outerPoint = new THREE.Vector3(nakshatraOuterRadius * cos(thetaStart), 0, nakshatraOuterRadius * sin(thetaStart));
      points.push(innerPoint, outerPoint);
      const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
      const dividerLine = new THREE.Line(lineGeometry, nakshatraDividerMaterial);
      nakshatraDividersGroup.add(dividerLine);

      // Divider Line for Padas
      for (let j = 1; j <= 3; j++) {
        const padaPoints = [];
        const thetaStartPada = thetaStart + (j * NAKSHATRA_ARC_RADIANS) / 4;
        const innerPointPada = new THREE.Vector3(nakshatraInnerRadius * cos(thetaStartPada), 0, nakshatraInnerRadius * sin(thetaStartPada));
        const outerPointPada = new THREE.Vector3(nakshatraOuterPadaRadius * cos(thetaStartPada), 0, nakshatraOuterPadaRadius * sin(thetaStartPada));
        padaPoints.push(innerPointPada, outerPointPada);
        const lineGeometryPada = new THREE.BufferGeometry().setFromPoints(padaPoints);
        const dividerLinePada = new THREE.Line(lineGeometryPada, nakshatraDividerMaterial);
        nakshatraDividersGroup.add(dividerLinePada);
      }
    });
    scene.add(nakshatraGroup);
    scene.add(nakshatraDividersGroup);


    // --- Vedic Zodiac Signs ---
    const zodiacSigns = [ /* ... names ... */
      'මේෂ', 'වෘෂභ', 'මිථුන', 'කටක', 'සිංහ', 'කන්‍යා',
      'තුලා', 'වෘෂ්චික', 'ධනු', 'මකර', 'කුම්භ', 'මීන'
    ];
    const zodiacGroup = new THREE.Group();
    const zodiacDividersGroup = new THREE.Group(); // Group for divider lines

    zodiacSigns.forEach((name, i) => {
      const thetaStart = i * ZODIAC_ARC_RADIANS;
      const thetaLength = ZODIAC_ARC_RADIANS;
      const midAngle = thetaStart + thetaLength / 2;

      // Arc geometry
      const arcGeometry = new THREE.RingGeometry(zodiacInnerRadius, zodiacOuterRadius, 4, 1, thetaStart, thetaLength);
      const arcMesh = new THREE.Mesh(arcGeometry, i % 2 === 0 ? zodiacArcMaterial : zodiacArcMaterialAlt);
      arcMesh.rotation.x = -Math.PI / 2;
      zodiacGroup.add(arcMesh);

      // Text sprite
      const textRadius = zodiacOuterRadius * 0.92;
      const x = textRadius * cos(midAngle);
      const z = textRadius * sin(midAngle);
      const sprite = createTextSprite(name, 27, '#ffeecc');
      sprite.position.set(x, 0, z);
      zodiacGroup.add(sprite);

      // *** Add Divider Line at the start angle (thetaStart) ***
      const points = [];
      const innerPoint = new THREE.Vector3(zodiacInnerRadius * cos(thetaStart), 0, zodiacInnerRadius * sin(thetaStart));
      const outerPoint = new THREE.Vector3(zodiacOuterRadius * cos(thetaStart), 0, zodiacOuterRadius * sin(thetaStart));
      points.push(innerPoint, outerPoint);

      const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
      const dividerLine = new THREE.Line(lineGeometry, zodiacDividerMaterial);
      zodiacDividersGroup.add(dividerLine);
    });
    scene.add(zodiacGroup);
    scene.add(zodiacDividersGroup); // Add dividers to the scene


    // --- Earth, Sun, Moon (Texturing) ---
    const earthTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
    const earthMaterial = new THREE.MeshStandardMaterial({ map: earthTexture, roughness: 0.7, metalness: 0.1 });
    const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, 64, 64), earthMaterial);
    scene.add(earth);

    const sunTexture = textureLoader.load('/images/sun.png');
    const sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture, toneMapped: false });
    const sun = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), sunMaterial);
    scene.add(sun);

    const moonTexture = textureLoader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg');
    const moonMaterial = new THREE.MeshStandardMaterial({ map: moonTexture, roughness: 0.9, metalness: 0.05 });
    const moon = new THREE.Mesh(new THREE.SphereGeometry(earthRadius * 0.27, 32, 32), moonMaterial);
    scene.add(moon);

    // --- Lighting ---
    scene.add(new THREE.AmbientLight(0x606080, 0.5));
    const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
    scene.add(sunLight);
    sunLight.target = earth;


    // --- Camera (initial placement, but now we use spherical coordinates for rotation) ---
    const initialCameraY = 60;
    const minCameraY = 15; // Minimum zoom distance
    const maxCameraY = 150; // Maximum zoom distance

    // Initial camera spherical coordinates
    let camRadius = initialCameraY;
    let camAzimuth = 0;      // theta, horizontal, in radians (around Y axis)
    let camPolar = PI / 2.1; // phi, vertical, in radians (PI/2 is top, 0 is horizon). Set so top view is default.

    function updateCameraPosition() {
      // Spherical to Cartesian conversion
      const x = camRadius * Math.sin(camPolar) * Math.sin(camAzimuth);
      const y = camRadius * Math.cos(camPolar);
      const z = camRadius * Math.sin(camPolar) * Math.cos(camAzimuth);
      camera.position.set(x, y, z);
      camera.up.set(0, 1, 0);
      camera.lookAt(0, 0, 0);
    }
    updateCameraPosition();

    // --- View Rotation Controls ---
    let isDragging = false;
    let previousMouseX = 0;
    let previousMouseY = 0;

    // Sensitivity factors for smooth control
    const ROTATE_SENSITIVITY = 0.008;
    const POLAR_SENSITIVITY = 0.008;
    const MIN_POLAR = 0.2;         // Not quite horizontal
    const MAX_POLAR = PI - 0.2;    // Not quite horizontal

    renderer.domElement.addEventListener('mousedown', function (event) {
      if (event.button !== 0) return; // Only left button
      isDragging = true;
      previousMouseX = event.clientX;
      previousMouseY = event.clientY;
    });

    renderer.domElement.addEventListener('mousemove', function (event) {
      if (!isDragging) return;
      const deltaX = event.clientX - previousMouseX;
      const deltaY = event.clientY - previousMouseY;
      previousMouseX = event.clientX;
      previousMouseY = event.clientY;

      camAzimuth -= deltaX * ROTATE_SENSITIVITY;
      camPolar -= deltaY * POLAR_SENSITIVITY;

      // Clamp polar angle to avoid flipping the camera
      camPolar = Math.max(MIN_POLAR, Math.min(MAX_POLAR, camPolar));

      updateCameraPosition();
    });

    renderer.domElement.addEventListener('mouseup', function () { isDragging = false; });
    renderer.domElement.addEventListener('mouseleave', function () { isDragging = false; });

    // --- Mouse Wheel Zoom (slightly changed: now updates camRadius) ---
    function handleMouseWheel(event) {
      event.preventDefault(); // Prevent default page scrolling

      const zoomIntensity = 0.05;
      const delta = event.deltaY;
      let zoomFactor = (delta < 0) ? (1 - zoomIntensity) : (1 + zoomIntensity);

      camRadius = max(minCameraY, min(maxCameraY, camRadius * zoomFactor));
      updateCameraPosition();
    }
    renderer.domElement.addEventListener('wheel', handleMouseWheel, { passive: false });

    // --- Simulation Variables & Constants ---
    let clock = new THREE.Clock();
    let animateFlag = true; // Start with animation running
    let simulationTime = 0;
    let speedDirection = 1; // +1 for forward, -1 for reverse
    const moonPeriodDays = 27.3;
    const daysPerYear = 365.25;
    const sunPeriodDays = daysPerYear;
    const earthRadiansPerDay = 2 * PI;
    // moon always faces the earth
    const moonRadiansPerDay = earthRadiansPerDay / moonPeriodDays;

    // Manual position control variables
    let manualSunPosition = null;
    let manualSunAjustment = 0;
    let manualMoonPosition = null;
    let manualMoonAdjustment = 0;
    let isManualPositionActive = false;
    let lastAdjustedObject = null; // Track which object was last adjusted

    // Debug flag
    const debug = true; // Set to true to enable console logs

    // Log initial state
    console.log("Initial animation state:", animateFlag ? "RUNNING" : "PAUSED");

    // --- Orbit Lines --- (Code remains the same)
    const createOrbitLine = (radius, color, segments = 120) => { /* ... */
      const points = [];
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * PI * 2;
        points.push(new THREE.Vector3(radius * cos(angle), 0, radius * sin(angle)));
      }
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.3 });
      return new THREE.Line(geometry, material);
    };
    const moonOrbitLine = createOrbitLine(moonOrbitRadius, 0xaaaaaa);
    scene.add(moonOrbitLine);
    const sunOrbitLine = createOrbitLine(sunOrbitRadius, 0xcccc66);
    scene.add(sunOrbitLine);


    // --- CONTROLS ---
    const playPauseBtn = document.getElementById('playPauseBtn');
    const reverseBtn = document.getElementById('reverseBtn'); // Get reverse button
    const speedUpBtn = document.getElementById('speedUpBtn');
    const speedDownBtn = document.getElementById('speedDownBtn');
    const resetSpeedBtn = document.getElementById('resetSpeedBtn');
    const speedDisplay = document.getElementById('speedDisplay');

    // Position controls
    const sunPositionSlider = document.getElementById('sunPositionSlider');
    const moonPositionSlider = document.getElementById('moonPositionSlider');
    const sunPositionDisplay = document.getElementById('sunPositionDisplay');
    const moonPositionDisplay = document.getElementById('moonPositionDisplay');
    const sunPositionText = document.getElementById('sunPositionText');
    const moonPositionText = document.getElementById('moonPositionText');
    const speedPresets = [
      { label: '1s = 1 Hour', value: 1 / 24 }, { label: '1s = 6 Hours', value: 6 / 24 }, { label: '1s = 1 Day', value: 1 },
      { label: '1s = 1 Week', value: 7 }, { label: '1s = 1 Month', value: 30 }, { label: '1s = 1 Year', value: daysPerYear }
    ];
    let currentSpeedIndex = 2; const defaultSpeedIndex = 2;

    // --- Moon Phase Display Elements & Config ---
    const moonPhaseNameElement = document.getElementById('moon-phase-name');
    const moonPhaseNames = [
      "පුර පෑලවිය",
      "පුර දියවක",
      "පුර තියවක",
      "පුර ජලවක",
      "පුර විසේනිය",
      "පුර සැටවක",
      "පුර සතවක",
      "පුර අටවක",
      "පුර නවවක",
      "පුර දසවක",
      "පුර එකොළොස්වක",
      "පුර දොළොස්වක",
      "පුර තෙළෙස්වක",
      "පුර තුදුස්වක",
      "පුර පසළොස්වක",
      "අව පෑලවිය",
      "අව දියවක",
      "අව තියවක",
      "අව ජලවක",
      "අව විසේනිය",
      "අව සැටවක",
      "අව සතවක",
      "අව අටවක",
      "අව නවවක",
      "අව දසවක",
      "අව එකොළොස්වක",
      "අව දොළොස්වක",
      "අව තෙළෙස්වක",
      "අව තුදුස්වක",
      "අමාවක"
    ];

    // This function is no longer used, but kept for reference
    function updatePlayPauseButton() {
      playPauseBtn.textContent = animateFlag ? 'Pause' : 'Play';
      if (debug) console.log("Button text updated to:", playPauseBtn.textContent);
    }
    function updateDirectionButton() { // Function to update reverse button text
      reverseBtn.textContent = speedDirection > 0 ? 'Forward' : 'Reverse';
    }
    function togglePlayPause() { animateFlag = !animateFlag; updatePlayPauseButton(); }
    function toggleDirection() { // Function to toggle direction
      speedDirection *= -1;
      updateDirectionButton();
      updateSpeedDisplayAndButtons(); // Update speed display too
    }
    function updateSpeedDisplayAndButtons() {
      const currentPreset = speedPresets[currentSpeedIndex];
      const directionLabel = speedDirection < 0 ? ' (Reverse)' : ''; // Add label for reverse
      speedDisplay.textContent = `Speed: ${currentPreset.label}${directionLabel}`;
      speedDownBtn.disabled = currentSpeedIndex === 0;
      speedUpBtn.disabled = currentSpeedIndex === speedPresets.length - 1;
    }

    playPauseBtn.addEventListener('click', togglePlayPause);
    reverseBtn.addEventListener('click', toggleDirection); // Add listener for reverse button
    speedUpBtn.addEventListener('click', () => { currentSpeedIndex = min(speedPresets.length - 1, currentSpeedIndex + 1); updateSpeedDisplayAndButtons(); });
    speedDownBtn.addEventListener('click', () => { currentSpeedIndex = max(0, currentSpeedIndex - 1); updateSpeedDisplayAndButtons(); });
    resetSpeedBtn.addEventListener('click', () => {
      currentSpeedIndex = defaultSpeedIndex;
      speedDirection = 1; // Also reset direction
      updateSpeedDisplayAndButtons();
      updateDirectionButton(); // Update direction button text
    });

    function handleKeyDown(event) { if (event.code === 'Space') { event.preventDefault(); togglePlayPause(); } }
    window.addEventListener('keydown', handleKeyDown);

    // Initial UI setup
    playPauseBtn.textContent = animateFlag ? 'Pause' : 'Play';
    console.log("Initial button text set to:", playPauseBtn.textContent);
    updateDirectionButton();
    updateSpeedDisplayAndButtons();

    // --- Position Control Functions ---
    // Convert degrees to radians
    function degreesToRadians(degrees) {
      return degrees * (PI / 180);
    }

    // Convert radians to degrees
    function radiansToDegrees(radians) {
      // Normalize to 0-2π range
      const normalizedRadians = radians % (2 * PI);
      const positiveRadians = normalizedRadians < 0 ? normalizedRadians + 2 * PI : normalizedRadians;
      return positiveRadians * (180 / PI);
    }

    // Format degrees as degrees, minutes, seconds
    function formatDegrees(degrees) {
      const totalSeconds = degrees * 3600;
      const degreesInt = Math.floor(degrees);
      const minutesFloat = (degrees - degreesInt) * 60;
      const minutesInt = Math.floor(minutesFloat);
      const secondsInt = Math.floor((minutesFloat - minutesInt) * 60);
      return `${degreesInt}° ${minutesInt}' ${secondsInt}"`;
    }

    // Formated degree in sinhala rashi names
    function formatDegreesSinhala(degrees) {
      const totalSeconds = degrees * 3600;
      const degreesInt = Math.floor(degrees);
      const minutesFloat = (degrees - degreesInt) * 60;
      const minutesInt = Math.floor(minutesFloat);
      const secondsInt = Math.floor((minutesFloat - minutesInt) * 60);
      const rashiIndex = Math.floor(degreesInt / 30);
      const rashiNames = ['මේෂ', 'වෘෂභ', 'මිථුන', 'කටක', 'සිංහ', 'කන්‍යා', 'තුලා', 'වෘෂ්චික', 'ධනු', 'මකර', 'කුම්භ', 'මීන'];
      const rashiName = rashiNames[rashiIndex];
      const rashiRemainingDegrees = degreesInt % 30;
      return `${rashiName} ${rashiRemainingDegrees}° ${minutesInt}' ${secondsInt}"`;
    }

    // --- MOON PHASE CALCULATION AND DISPLAY FUNCTION ---
    function updateMoonPhaseDisplay(currentSunAngle, currentMoonAngle) {
      if (!moonPhaseNameElement) return; // Safety check

      let elongation = (currentMoonAngle - currentSunAngle);
      // Normalize elongation to 0-2PI
      elongation = (elongation % (2 * PI) + 2 * PI) % (2 * PI);
      const elongationDegrees = elongation * (180 / PI); // Convert to degrees 0-360

      // Determine phase index (0-29 for 30 phases)
      // Each phase covers 360/30 = 12 degrees.
      const degreesPerPhase = 360 / 30;
      let phaseIndex = Math.floor(elongationDegrees / degreesPerPhase);

      // Ensure phaseIndex is within bounds (0 to 29)
      // Math.floor(360 / 12) = 30. If elongation is exactly 360 (or 2*PI), it should be phase 0.
      phaseIndex = phaseIndex % 30;

      moonPhaseNameElement.textContent = moonPhaseNames[phaseIndex];
    }

    // Update position displays
    function updatePositionDisplays() {
      // Get current angles
      let sunAngle, moonAngle;

      if (manualSunPosition !== null) {
        sunAngle = degreesToRadians(manualSunPosition);
      } else {
        sunAngle = (simulationTime / sunPeriodDays) * 2 * PI;
      }

      if (manualMoonPosition !== null) {
        moonAngle = degreesToRadians(manualMoonPosition);
      } else {
        moonAngle = (simulationTime / moonPeriodDays) * 2 * PI;
      }

      // Convert to degrees and format
      const sunDegrees = radiansToDegrees(sunAngle);
      const moonDegrees = radiansToDegrees(moonAngle);

      sunPositionDisplay.textContent = formatDegrees(sunDegrees);
      moonPositionDisplay.textContent = formatDegrees(moonDegrees);

      sunPositionText.textContent = formatDegreesSinhala(sunDegrees);
      moonPositionText.textContent = formatDegreesSinhala(moonDegrees);

      // Update sliders if not being dragged
      if (!isManualPositionActive) {
        sunPositionSlider.value = sunDegrees;
        moonPositionSlider.value = moonDegrees;
      }
      updateMoonPhaseDisplay(sunAngle, moonAngle); // Update moon phase
    }

    // Handle slider changes
    sunPositionSlider.addEventListener('input', function () {
      if (debug) console.log("Sun slider adjusted to:", this.value);

      // Store the current positions
      manualSunPosition = parseFloat(this.value);
      lastAdjustedObject = 'sun'; // Track that sun was last adjusted

      // Calculate current moon angle in degrees if not already set
      if (manualMoonPosition === null) {
        const moonX = moon.position.x;
        const moonZ = moon.position.z;
        const moonAngle = Math.atan2(moonZ, moonX);
        manualMoonPosition = radiansToDegrees(moonAngle);
        if (debug) console.log("Captured current moon position:", manualMoonPosition);
      }

      // Update positions immediately
      const sunAngle = degreesToRadians(manualSunPosition);
      sun.position.set(sunOrbitRadius * cos(sunAngle), 0, sunOrbitRadius * sin(sunAngle));
      sunLight.position.copy(sun.position);

      // Update displays 
      updatePositionDisplays();

      // Pause animation if it's running
      if (animateFlag) {
        if (debug) console.log("Pausing animation due to sun slider adjustment");
        animateFlag = false;
        updatePlayPauseButton();
      }

      manualSunAjustment = sunAngle - currentSunPosition();
      if (manualSunAjustment < 0) {
        manualSunAjustment += PI * 2;
      }
    });

    moonPositionSlider.addEventListener('input', function () {
      if (debug) console.log("Moon slider adjusted to:", this.value);

      // Store the current positions
      manualMoonPosition = parseFloat(this.value);
      lastAdjustedObject = 'moon'; // Track that moon was last adjusted

      // Calculate current sun angle in degrees if not already set
      if (manualSunPosition === null) {
        const sunX = sun.position.x;
        const sunZ = sun.position.z;
        const sunAngle = Math.atan2(sunZ, sunX);
        manualSunPosition = radiansToDegrees(sunAngle);
        if (debug) console.log("Captured current sun position:", manualSunPosition);
      }

      // Update positions immediately
      const moonAngle = degreesToRadians(manualMoonPosition);
      moon.position.set(moonOrbitRadius * cos(moonAngle), 0, moonOrbitRadius * sin(moonAngle));

      // Update displays
      updatePositionDisplays();

      // Pause animation if it's running
      if (animateFlag) {
        if (debug) console.log("Pausing animation due to moon sl ider adjustment");
        animateFlag = false;
        updatePlayPauseButton();
      }
      manualMoonAdjustment = moonAngle - currentMoonPosition();
      if (manualMoonAdjustment < 0) {
        manualMoonAdjustment += PI * 2;
      }
    });
    // Handle play/pause button click
    playPauseBtn.addEventListener('click', function () {
      // Get the current button text to determine the current state
      const currentButtonText = playPauseBtn.textContent;
      console.log("Play/Pause button clicked. Current button text:", currentButtonText);

      if (currentButtonText === "Pause") {
        // Button says "Pause", so we're currently running and want to pause
        console.log("Pausing animation");
        animateFlag = false;
        playPauseBtn.textContent = "Play";
      } else {
        // Button says "Play", so we're currently paused and want to resume
        console.log("Resuming animation");

        // Check if we have manual positions set
        if (manualSunPosition !== null || manualMoonPosition !== null) {
          console.log("Manual positions detected:",
            "Sun:", manualSunPosition,
            "Moon:", manualMoonPosition);

          // Calculate what simulationTime would give this position
          if (lastAdjustedObject === 'sun' && manualSunPosition !== null) {
            const sunAngle = degreesToRadians(manualSunPosition);
            simulationTime = (sunAngle * sunPeriodDays) / (2 * PI);
            console.log("Setting simulation time based on sun position:", simulationTime);
          } else if (lastAdjustedObject === 'moon' && manualMoonPosition !== null) {
            const moonAngle = degreesToRadians(manualMoonPosition);
            simulationTime = (moonAngle * moonPeriodDays) / (2 * PI);
            console.log("Setting simulation time based on moon position:", simulationTime);
          }

          // Clear manual positions so animation can continue from current position
          console.log("Clearing manual positions");
          manualSunPosition = null;
          manualMoonPosition = null;
        }

        animateFlag = true;
        playPauseBtn.textContent = "Pause";
      }

      console.log("New animation state:", animateFlag ? "RUNNING" : "PAUSED");
    });

    // --- Mouse Wheel Zoom ---
    function handleMouseWheel(event) {
      event.preventDefault(); // Prevent default page scrolling

      const zoomIntensity = 0.05; // How much to zoom per scroll tick
      const delta = event.deltaY;

      let zoomFactor;
      if (delta < 0) { // Scrolling up -> Zoom In
        zoomFactor = 1 - zoomIntensity;
      } else { // Scrolling down -> Zoom Out
        zoomFactor = 1 + zoomIntensity;
      }

      // Adjust camera Y position, clamping within limits
      camera.position.y = max(minCameraY, min(maxCameraY, camera.position.y * zoomFactor));

      // No need for updateProjectionMatrix() when changing position
      camera.lookAt(0, 0, 0); // Ensure camera still looks at the center
    }
    renderer.domElement.addEventListener('wheel', handleMouseWheel, { passive: false }); // Add wheel listener to canvas

    function currentMoonPosition() {
      return (simulationTime / moonPeriodDays) * 2 * PI;
    }

    function currentSunPosition() {
      return (simulationTime / sunPeriodDays) * 2 * PI;
    }

    function getMoonAngle() {
      return currentMoonPosition() + manualMoonAdjustment;
    }

    function getSunAngle() {
      return currentSunPosition() + manualSunAjustment;
    }


    // --- Utility Functions ---

    // Existing function for Sprites (used for Nakshatras)
    function createTextSprite(message, fontSize = 30, color = '#ffffff') {
      const effectiveScale = window.devicePixelRatio || 1;
      const padding = 10 * (fontSize / 30);
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = `bold ${fontSize}px sans-serif`;
      const textMetrics = ctx.measureText(message);
      const textWidth = textMetrics.width;
      canvas.width = (textWidth + padding * 2) * effectiveScale;
      canvas.height = (fontSize + padding * 2) * effectiveScale;
      ctx.scale(effectiveScale, effectiveScale);
      ctx.font = `bold ${fontSize}px sans-serif`;
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      ctx.shadowBlur = 3 * effectiveScale;
      ctx.shadowOffsetX = 1 * effectiveScale;
      ctx.shadowOffsetY = 1 * effectiveScale;
      ctx.fillText(message, (textWidth + padding * 2) / 2, (fontSize + padding * 2) / 2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      // Use SpriteMaterial for Sprites
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true, alphaTest: 0.1, depthTest: false, sizeAttenuation: true });
      const sprite = new THREE.Sprite(material);
      const spriteScaleFactor = 0.05; // Adjust this factor as needed
      const spriteWidth = canvas.width / effectiveScale * spriteScaleFactor * (fontSize / 30);
      const spriteHeight = canvas.height / effectiveScale * spriteScaleFactor * (fontSize / 30);
      sprite.scale.set(spriteWidth, spriteHeight, 1);
      return sprite;
    }

    // =========================
    // === MINI MOON PHASE 3D VIEW ===
    // =========================

    // (Add a <canvas id="moon-phase-3d" width="170" height="170"></canvas> in your #moon-phase-container)

    // 1. Setup mini Three.js scene for the 3D moon phase
    const moonPhase3dCanvas = document.getElementById('moon-phase-3d');
    const moonPhase3dRenderer = new THREE.WebGLRenderer({
      canvas: moonPhase3dCanvas,
      alpha: true,
      antialias: true
    });
    moonPhase3dRenderer.setClearColor(0x111111, 0);

    const moon3dScene = new THREE.Scene();
    const moon3dCamera = new THREE.PerspectiveCamera(24, 1, 0.1, 10);
    moon3dCamera.position.set(0, 0, 3);
    moon3dCamera.lookAt(0, 0, 0);

    // Use the same moonMaterial for fidelity
    const moon3d = new THREE.Mesh(
      new THREE.SphereGeometry(1, 64, 64),
      moonMaterial
    );
    moon3dScene.add(moon3d);

    const moon3dLight = new THREE.DirectionalLight(0xffffff, 2.2);
    moon3dScene.add(moon3dLight);
    moon3dScene.add(new THREE.AmbientLight(0x303040, 0.7));

    // ==============================
    // ========== ANIMATION =========
    // ==============================

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (animateFlag) {
        const currentSpeedValue = speedPresets[currentSpeedIndex].value;
        const simulationDaysElapsed = delta * currentSpeedValue * speedDirection;
        simulationTime += simulationDaysElapsed;

        const moonAngle = getMoonAngle();
        const sunAngle = getSunAngle();

        moon.position.set(moonOrbitRadius * cos(moonAngle), 0, moonOrbitRadius * sin(moonAngle));
        sun.position.set(sunOrbitRadius * cos(sunAngle), 0, sunOrbitRadius * sin(sunAngle));
        sunLight.position.copy(sun.position);

        updatePositionDisplays();
        earth.rotation.y += earthRadiansPerDay * simulationDaysElapsed;
        // since moon always faces the earth, we have to rotate it same angle 
        moon.rotation.y = -moonAngle;
      }

      // --- 3D Moon Mini Phase View Update ---
      // Camera is positioned as if you are at the earth, looking at the moon
      const miniMoonAngle = getMoonAngle();
      const miniSunAngle = getSunAngle();

      // Camera looks from earth to moon
      const camDistance = 6;
      const camX = Math.cos(miniMoonAngle) * camDistance;
      const camZ = Math.sin(miniMoonAngle) * camDistance;
      moon3dCamera.position.set(camX, 0, camZ);
      moon3dCamera.up.set(0, 1, 0);
      moon3dCamera.lookAt(0, 0, 0);

      // Sunlight illuminates from sun's direction
      const sunX = Math.cos(miniSunAngle) * camDistance * -  1;
      const sunZ = Math.sin(miniSunAngle) * camDistance * - 1;
      moon3dLight.position.set(sunX, 0, sunZ);
      moon3dLight.target.position.set(0, 0, 0);
      moon3dLight.target.updateMatrixWorld();

      // (Optional: If you want to keep north-up, set .rotation.y = 0)
      moon3d.rotation.y = -miniMoonAngle;

      moonPhase3dRenderer.render(moon3dScene, moon3dCamera);

      // --- Main scene render ---
      renderer.render(scene, camera);
    }


    // ... [keep all your other utility, controls, UI, etc. code here] ...

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      updateCameraPosition();
    }, false);

    animate();
    updatePositionDisplays();
  </script>


</body>

</html>