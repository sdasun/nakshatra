<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>27 Nakshatra & Zodiac 3D - V7 (Features)</title>
  <style>
    /* ... all your CSS unchanged ... */
    body {
      margin: 0;
      background: #0a0a1a;
      overflow: hidden;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-image: url('/images/sky.png');
      background-blend-mode: overlay;
      background-color: rgba(0, 0, 0, 0.75);
    }

    canvas {
      display: block;
    }

    #controls-container {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      padding: 12px 20px;
      background: rgba(30, 30, 50, 0.85);
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      z-index: 100;
      align-items: center;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    button {
      padding: 8px 12px;
      background: #4a4a7a;
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.2s ease, transform 0.1s ease;
      min-width: 50px;
      text-align: center;
    }

    button:hover {
      background: #5a5a8a;
    }

    button:active {
      background: #3a3a6a;
      transform: scale(0.95);
    }

    button:disabled {
      background: #33334c;
      color: #777799;
      cursor: not-allowed;
    }

    #speedDisplay {
      color: #e0e0ff;
      font-size: 13px;
      min-width: 120px;
      text-align: center;
      padding: 5px;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
    }

    #moon-phase-container {
      position: absolute;
      top: 15px;
      right: 15px;
      padding: 8px;
      /* background: rgba(30, 30, 50, 0.85); */
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      color: white;
      min-width: 200px;
      min-height: 250px;
    }

    #moon-phase-container canvas {
      background-color: rgba(255, 255, 255, 0);
    }

    #moon-phase-image {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      object-fit: cover;
      background-color: #111;
      border: 5px solid rgba(30, 30, 50, 1);
    }

    #moon-phase-name {
      font-size: 21px;
      text-align: center;
      max-width: 150px;
    }
  </style>
</head>

<body>
  <!-- MOON PHASE DISPLAY ELEMENT -->
  <div id="moon-phase-container">
    <canvas id="moon-phase-3d" width="170" height="170"></canvas>


    <span id="moon-phase-name">Loading...</span>
  </div>
  <div id="controls-container">
    <div class="control-group">
      <button id="playPauseBtn">Pause</button>
    </div>
    <div class="control-group">
      <button id="reverseBtn" title="Toggle Direction">Forward</button>
    </div>
    <div class="control-group">
      <button id="labelToggleBtn" style="min-width:80px;">Hide Labels</button>
    </div>
    <div class="control-group">
      <button id="speedDownBtn" title="Slower">-</button>
      <span id="speedDisplay">Speed: 1s = 1 Day</span>
      <button id="speedUpBtn" title="Faster">+</button>
      <button id="resetSpeedBtn" title="Reset Speed">Reset</button>
    </div>
    <div class="control-group" style="border-left: 1px solid rgba(255,255,255,0.2); padding-left: 10px;">
      <div style="display: flex; align-items: center; gap: 8px;">
        <span style="min-width: 40px; color: #ffcc66;">Sun:</span>
        <span id="sunPositionDisplay"
          style="min-width: 80px; background-color: rgba(0, 0, 0, 0.2); padding: 3px 6px; border-radius: 4px; font-size: 13px;">0°
          0' 0"</span>
        <input type="text" id="sunKnob" value="0" style="width:54px;height:54px;display:inline-block;">
        <span id="sunPositionText" style="font-size: 18px; color: #ffcc66; min-width: 150px;"></span>
      </div>
      <div style="display: flex; align-items: center; gap: 8px;">
        <span style="min-width: 40px; color: #aaccff;">Moon:</span>
        <span id="moonPositionDisplay"
          style="min-width: 80px; background-color: rgba(0, 0, 0, 0.2); padding: 3px 6px; border-radius: 4px; font-size: 13px;">0°
          0' 0"</span>
        <input type="text" id="moonKnob" value="0" style="width:54px;height:54px;display:inline-block;">
        <span id="moonPositionText" style="font-size: 18px; color: #aaccff; min-width: 150px;"></span>
      </div>

    </div>
  </div>
  <a class="logo" href="https://tharukirana.com" target="_blank"
    style="position: absolute; top: 10px; left: 10px; z-index: 100; display: flex; align-items: center; text-decoration: none; gap: 10px;">
    <img src="/images/tharukirana_logo_small2.png" alt="Tharu Kirana Logo" title="Tharu Kirana Logo"
      style="width: 150px; height: auto; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);">
    <div style="color: #ffffff; font-size: 16px; line-height: 1.4;">
      <strong style="font-size: 18px;">පොහොය නාම කරණ Simulation</strong><br>
      <span style="font-size: 14px;">Developed by Tharu Kirana</span>
    </div>
  </a>


  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jQuery-Knob/1.2.13/jquery.knob.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    const { PI, cos, sin, min, max } = Math;

    // ----- MAIN SCENE SETUP -----
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const textureLoader = new THREE.TextureLoader();

    // --- Shared Constants ---
    const NAKSHATRA_COUNT = 27;
    const ZODIAC_COUNT = 12;
    const NAKSHATRA_ARC_RADIANS = -(2 * PI) / NAKSHATRA_COUNT;
    const ZODIAC_ARC_RADIANS = -(2 * PI) / ZODIAC_COUNT;
    const earthRadius = 2;
    const moonOrbitRadius = earthRadius * 3.5;
    const moonOrbitDeclination = degreesToRadians(-5);
    const sunOrbitDeclination = degreesToRadians(23.45);
    const zodiacInnerRadius = 21;
    const zodiacOuterRadius = 23;
    const nakshatraInnerRadius = 23
    const nakshatraOuterPadaRadius = 24
    const nakshatraOuterRadius = 25
    const sunOrbitRadius = 23;

    // --- Materials ---
    const nakshatraArcMaterial = new THREE.MeshBasicMaterial({ color: 0x555599, side: THREE.DoubleSide, transparent: true, opacity: 0.1 });
    const nakshatraArcMaterialAlt = new THREE.MeshBasicMaterial({ color: 0x6666AA, side: THREE.DoubleSide, transparent: true, opacity: 0.1 });
    const nakshatraDividerMaterial = new THREE.LineBasicMaterial({ color: 0xAAAAFF, linewidth: 2 });

    const zodiacArcMaterial = new THREE.MeshBasicMaterial({ color: 0x998855, side: THREE.DoubleSide, transparent: true, opacity: 0.1 });
    const zodiacArcMaterialAlt = new THREE.MeshBasicMaterial({ color: 0xAA9966, side: THREE.DoubleSide, transparent: true, opacity: 0.1 });
    const zodiacDividerMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFCC, linewidth: 2 });


    // --- Nakshatras ---
    const nakshatras = [
      'අස්විද', 'බෙරණ', 'කැති', 'රෙහෙණ', 'මුවසිරිස', 'අද', 'පුනාවස', 'පුස',
      'අස්ලිය', 'මා', 'පුවපල්', 'උත්‍රපල්', 'හත', 'සිත', 'සා',
      'විසා (වෛශාක්‍ය)', 'අනුර', 'දෙට', 'මුල', 'පුවසල', 'උත්‍රසල',
      'සුවන', 'දෙනට', 'සියාවස', 'පුවපුටුප', 'උත්‍රපුටුප', 'රේවතී'
    ];
    const lunarMonthNames = [
      'වප්', '', 'ඉල්', '', 'උඳුවප්', '', '', 'දුරුතු',
      '', 'නවම්', '', 'මැදින්', '', 'බක්', '',
      'වෙසක්', '', 'පොසොන්', '', 'ඇසල', '',
      'නිකිණි', '', '', 'බිනර', '', ''
    ]
    const nakshatraGroup = new THREE.Group();
    const nakshatraDividersGroup = new THREE.Group();

    nakshatras.forEach((name, i) => {
      const thetaStart = i * NAKSHATRA_ARC_RADIANS;
      const thetaLength = NAKSHATRA_ARC_RADIANS;
      const midAngle = thetaStart + thetaLength / 2;

      // Arc geometry
      const arcGeometry = new THREE.RingGeometry(nakshatraInnerRadius, nakshatraOuterRadius, 3, 1, thetaStart, thetaLength);
      const arcMesh = new THREE.Mesh(arcGeometry, i % 2 === 0 ? nakshatraArcMaterial : nakshatraArcMaterialAlt);
      arcMesh.rotation.x = -Math.PI / 2;
      nakshatraGroup.add(arcMesh);

      // Text sprite (Keeping Nakshatras as sprites for now, simpler)
      const textRadius = nakshatraOuterRadius * 1.04; // Position outside
      const x = textRadius * cos(midAngle);
      const z = textRadius * sin(midAngle);
      const sprite = createTextSprite(name, 24, '#ddddff'); // Existing function
      sprite.position.set(x, 0, z);
      nakshatraGroup.add(sprite);

      // Text plane for lunar month names
      const monthText = lunarMonthNames[i];
      if (monthText.trim() !== '') { // Skip if the text is empty
        const monthSprite = createTextSprite(monthText, 24, '#ffff00'); // New function for text on planes
        // place it under the nakshatra text centered
        monthSprite.position.set(x, 0, z + 1); // Adjust Y position to be below the nakshatra
        // monthSprite.rotation.x = -PI / 2; // Rotate to face the camera
        nakshatraGroup.add(monthSprite);
      }


      // Divider Line
      const points = [];
      const innerPoint = new THREE.Vector3(nakshatraInnerRadius * cos(thetaStart), 0, nakshatraInnerRadius * sin(thetaStart));
      const outerPoint = new THREE.Vector3(nakshatraOuterRadius * cos(thetaStart), 0, nakshatraOuterRadius * sin(thetaStart));
      points.push(innerPoint, outerPoint);
      const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
      const dividerLine = new THREE.Line(lineGeometry, nakshatraDividerMaterial);
      nakshatraDividersGroup.add(dividerLine);

      // Divider Line for Padas
      for (let j = 1; j <= 3; j++) {
        const padaPoints = [];
        const thetaStartPada = thetaStart + (j * NAKSHATRA_ARC_RADIANS) / 4;
        const innerPointPada = new THREE.Vector3(nakshatraInnerRadius * cos(thetaStartPada), 0, nakshatraInnerRadius * sin(thetaStartPada));
        const outerPointPada = new THREE.Vector3(nakshatraOuterPadaRadius * cos(thetaStartPada), 0, nakshatraOuterPadaRadius * sin(thetaStartPada));
        padaPoints.push(innerPointPada, outerPointPada);
        const lineGeometryPada = new THREE.BufferGeometry().setFromPoints(padaPoints);
        const dividerLinePada = new THREE.Line(lineGeometryPada, nakshatraDividerMaterial);
        nakshatraDividersGroup.add(dividerLinePada);
      }
    });
    scene.add(nakshatraGroup);
    scene.add(nakshatraDividersGroup);


    // --- Vedic Zodiac Signs ---
    const zodiacSigns = [ /* ... names ... */
      'මේෂ', 'වෘෂභ', 'මිථුන', 'කටක', 'සිංහ', 'කන්‍යා',
      'තුලා', 'වෘෂ්චික', 'ධනු', 'මකර', 'කුම්භ', 'මීන'
    ];
    const zodiacGroup = new THREE.Group();
    const zodiacDividersGroup = new THREE.Group(); // Group for divider lines

    zodiacSigns.forEach((name, i) => {
      const thetaStart = i * ZODIAC_ARC_RADIANS;
      const thetaLength = ZODIAC_ARC_RADIANS;
      const midAngle = thetaStart + thetaLength / 2;

      // Arc geometry
      const arcGeometry = new THREE.RingGeometry(zodiacInnerRadius, zodiacOuterRadius, 4, 1, thetaStart, thetaLength);
      const arcMesh = new THREE.Mesh(arcGeometry, i % 2 === 0 ? zodiacArcMaterial : zodiacArcMaterialAlt);
      arcMesh.rotation.x = -Math.PI / 2;
      zodiacGroup.add(arcMesh);

      // Text sprite
      const textRadius = zodiacOuterRadius * 0.92;
      const x = textRadius * cos(midAngle);
      const z = textRadius * sin(midAngle);
      const sprite = createTextSprite(name, 27, '#ffeecc');
      sprite.position.set(x, 0, z);
      zodiacGroup.add(sprite);

      // *** Add Divider Line at the start angle (thetaStart) ***
      const points = [];
      const innerPoint = new THREE.Vector3(zodiacInnerRadius * cos(thetaStart), 0, zodiacInnerRadius * sin(thetaStart));
      const outerPoint = new THREE.Vector3(zodiacOuterRadius * cos(thetaStart), 0, zodiacOuterRadius * sin(thetaStart));
      points.push(innerPoint, outerPoint);

      const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
      const dividerLine = new THREE.Line(lineGeometry, zodiacDividerMaterial);
      zodiacDividersGroup.add(dividerLine);
    });
    scene.add(zodiacGroup);
    scene.add(zodiacDividersGroup); // Add dividers to the scene


    // --- Earth, Sun, Moon (Texturing) ---
    const earthTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
    const earthMaterial = new THREE.MeshStandardMaterial({ map: earthTexture, roughness: 0.7, metalness: 0.1 });
    const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, 64, 64), earthMaterial);
    // 23.45 degrees tilt
    earth.rotation.x = degreesToRadians(sunOrbitDeclination);
    scene.add(earth);

    // earth equator ring 
    const earthEquatorGeometry = new THREE.RingGeometry(earthRadius, earthRadius * 1.1, 64);
    const earthEquatorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
    const earthEquator = new THREE.Mesh(earthEquatorGeometry, earthEquatorMaterial);
    earthEquator.rotation.x = -PI / 2;
    earthEquator.position.set(0, 0, 0);
    scene.add(earthEquator);

    // add earth polar axis
    const earthAxisGeometry = new THREE.CylinderGeometry(0.075, 0.075, earthRadius * 2.3, 32);
    const earthAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const earthAxis = new THREE.Mesh(earthAxisGeometry, earthAxisMaterial);
    earthAxis.rotation.x = degreesToRadians(23.45);
    earthAxis.rotation.y = -PI / 2;
    earthAxis.position.set(0, 0, 0);
    scene.add(earthAxis);

    const sunTexture = textureLoader.load('/images/sun.png');
    const sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture, toneMapped: false });
    const sun = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), sunMaterial);
    scene.add(sun);

    const moonOrbitGroup = new THREE.Group();
    moonOrbitGroup.rotation.x = moonOrbitDeclination; // same as orbit line
    scene.add(moonOrbitGroup);

    const moonTexture = textureLoader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg');
    const moonMaterial = new THREE.MeshStandardMaterial({ map: moonTexture, roughness: 0.9, metalness: 0.05 });
    const moon = new THREE.Mesh(new THREE.SphereGeometry(earthRadius * 0.27, 32, 32), moonMaterial);
    moonOrbitGroup.add(moon);

    // --- Lighting ---
    scene.add(new THREE.AmbientLight(0x606080, 0.5));
    const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
    scene.add(sunLight);
    sunLight.target = earth;


    // --- Camera (initial placement, but now we use spherical coordinates for rotation) ---
    // --- Camera Spherical Coordinates ---
    let camRadius = 60;
    let camAzimuth = 0;         // θ (longitude, around Y), can be any value for infinite rotation
    let camPolar = Math.PI / 2.1; // φ (latitude, vertical)
    const minCameraY = 15;
    const maxCameraY = 150;
    const MIN_POLAR = 0.2;
    const MAX_POLAR = Math.PI - 0.2;

    function updateCameraPosition() {
      const x = camRadius * Math.sin(camPolar) * Math.sin(camAzimuth);
      const y = camRadius * Math.cos(camPolar);
      const z = camRadius * Math.sin(camPolar) * Math.cos(camAzimuth);
      camera.position.set(x, y, z);
      camera.up.set(0, 1, 0);
      camera.lookAt(0, 0, 0);
    }
    updateCameraPosition();

    // --- Improved View Rotation Controls ---
    let isDragging = false;
    let lastX = 0, lastY = 0;
    const ROTATE_SENSITIVITY = 0.008;
    const POLAR_SENSITIVITY = 0.008;

    function wrapAzimuth(az) {
      // Allow azimuth to grow/shrink without limit for seamless rotation
      return az;
    }

    renderer.domElement.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      camAzimuth = wrapAzimuth(camAzimuth - dx * ROTATE_SENSITIVITY);
      camPolar -= dy * POLAR_SENSITIVITY;
      camPolar = Math.max(MIN_POLAR, Math.min(MAX_POLAR, camPolar));
      updateCameraPosition();
    });

    renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
    renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; });

    // --- Zoom: mouse wheel & pinch support ---
    function handleZoom(deltaY, factor = 0.05) {
      camRadius = Math.max(minCameraY, Math.min(maxCameraY, camRadius * (1 + factor * Math.sign(deltaY))));
      updateCameraPosition();
    }
    renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault();
      handleZoom(e.deltaY);
    }, { passive: false });
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        isDragging = false; // disable drag on pinch
        pinchStartDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        pinchStartRadius = camRadius;
      }
    });
    let pinchStartDist = 0, pinchStartRadius = 0;
    renderer.domElement.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2 && pinchStartDist) {
        e.preventDefault();
        const dist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        const zoomDelta = pinchStartDist - dist;
        camRadius = Math.max(minCameraY, Math.min(maxCameraY, pinchStartRadius + zoomDelta * 0.12));
        updateCameraPosition();
      }
    }, { passive: false });
    renderer.domElement.addEventListener('touchend', (e) => {
      pinchStartDist = 0;
    });

    // --- Camera Preset Buttons ---
    const viewPresets = [
      { label: "Top", polar: 0.21 * Math.PI, azimuth: 0 },
      { label: "Side", polar: Math.PI / 2, azimuth: 0 },
      { label: "Bottom", polar: Math.PI - 0.21 * Math.PI, azimuth: 0 },
      { label: "Oblique", polar: Math.PI / 3, azimuth: Math.PI / 4 }
    ];

    // Insert preset buttons into the controls panel
    const controls = document.getElementById("controls-container");
    const presetDiv = document.createElement("div");
    presetDiv.className = "control-group";
    presetDiv.style.borderLeft = "1px solid rgba(255,255,255,0.2)";
    presetDiv.style.paddingLeft = "10px";
    presetDiv.style.gap = "7px";
    viewPresets.forEach(preset => {
      const btn = document.createElement("button");
      btn.textContent = preset.label;
      btn.onclick = () => {
        camPolar = preset.polar;
        camAzimuth = preset.azimuth;
        updateCameraPosition();
      };
      presetDiv.appendChild(btn);
    });
    controls.appendChild(presetDiv);

    // --- Keyboard shortcuts for camera view presets ---
    window.addEventListener('keydown', (e) => {
      if (e.altKey && e.code.startsWith("Digit")) {
        let idx = +e.code.slice(-1) - 1;
        if (idx >= 0 && idx < viewPresets.length) {
          camPolar = viewPresets[idx].polar;
          camAzimuth = viewPresets[idx].azimuth;
          updateCameraPosition();
        }
      }
    });

    // --- Simulation Variables & Constants ---
    let clock = new THREE.Clock();
    let animateFlag = true; // Start with animation running
    let simulationTime = 0;
    let speedDirection = 1; // +1 for forward, -1 for reverse
    const moonPeriodDays = 27.3;
    const daysPerYear = 365.25;
    const sunPeriodDays = daysPerYear;
    const earthRadiansPerDay = 2 * PI;
    // moon always faces the earth
    const moonRadiansPerDay = earthRadiansPerDay / moonPeriodDays;

    // Manual position control variables
    let manualSunPosition = null;
    let manualSunAjustment = 0;
    let manualMoonPosition = null;
    let manualMoonAdjustment = 0;
    let isManualPositionActive = false;
    let lastAdjustedObject = null; // Track which object was last adjusted

    // Debug flag
    const debug = false; // Set to true to enable console logs

    // Log initial state
    console.log("Initial animation state:", animateFlag ? "RUNNING" : "PAUSED");

    // --- Orbit Lines --- (Code remains the same)
    const createOrbitLine = (radius, color, segments = 120, materialOverride = null) => { /* ... */
      const points = [];
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * PI * 2;
        points.push(new THREE.Vector3(radius * cos(angle), 0, radius * sin(angle)));
      }
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = materialOverride ?? new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.3 });
      return new THREE.Line(geometry, material);
    };
    const moonOrbitLine = createOrbitLine(moonOrbitRadius, 0xaaaaaa, 120, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }));
    moonOrbitGroup.add(moonOrbitLine);
    const sunOrbitLine = createOrbitLine(sunOrbitRadius, 0xcccc66);
    scene.add(sunOrbitLine);


    // --- CONTROLS ---
    const playPauseBtn = document.getElementById('playPauseBtn');
    const reverseBtn = document.getElementById('reverseBtn');
    const labelToggleBtn = document.getElementById("labelToggleBtn");
    const speedUpBtn = document.getElementById('speedUpBtn');
    const speedDownBtn = document.getElementById('speedDownBtn');
    const resetSpeedBtn = document.getElementById('resetSpeedBtn');
    const speedDisplay = document.getElementById('speedDisplay');

    // Position controls
    const sunPositionSlider = document.getElementById('sunPositionSlider');
    const moonPositionSlider = document.getElementById('moonPositionSlider');
    const sunPositionDisplay = document.getElementById('sunPositionDisplay');
    const moonPositionDisplay = document.getElementById('moonPositionDisplay');
    const sunPositionText = document.getElementById('sunPositionText');
    const moonPositionText = document.getElementById('moonPositionText');
    const speedPresets = [
      { label: '1s = 1 Hour', value: 1 / 24 }, { label: '1s = 6 Hours', value: 6 / 24 }, { label: '1s = 1 Day', value: 1 },
      { label: '1s = 1 Week', value: 7 }, { label: '1s = 1 Month', value: 30 }, { label: '1s = 1 Year', value: daysPerYear }
    ];
    let currentSpeedIndex = 2; const defaultSpeedIndex = 2;

    // --- Moon Phase Display Elements & Config ---
    const moonPhaseNameElement = document.getElementById('moon-phase-name');
    const moonPhaseNames = [
      "පුර පෑලවිය",
      "පුර දියවක",
      "පුර තියවක",
      "පුර ජලවක",
      "පුර විසේනිය",
      "පුර සැටවක",
      "පුර සතවක",
      "පුර අටවක",
      "පුර නවවක",
      "පුර දසවක",
      "පුර එකොළොස්වක",
      "පුර දොළොස්වක",
      "පුර තෙළෙස්වක",
      "පුර තුදුස්වක",
      "පුර පසළොස්වක",
      "අව පෑලවිය",
      "අව දියවක",
      "අව තියවක",
      "අව ජලවක",
      "අව විසේනිය",
      "අව සැටවක",
      "අව සතවක",
      "අව අටවක",
      "අව නවවක",
      "අව දසවක",
      "අව එකොළොස්වක",
      "අව දොළොස්වක",
      "අව තෙළෙස්වක",
      "අව තුදුස්වක",
      "අමාවක"
    ];

    // This function is no longer used, but kept for reference
    function updatePlayPauseButton() {
      playPauseBtn.textContent = animateFlag ? 'Pause' : 'Play';
      if (debug) console.log("Button text updated to:", playPauseBtn.textContent);
    }
    function updateDirectionButton() { // Function to update reverse button text
      reverseBtn.textContent = speedDirection > 0 ? 'Forward' : 'Reverse';
    }
    function togglePlayPause() { animateFlag = !animateFlag; updatePlayPauseButton(); }
    function toggleDirection() { // Function to toggle direction
      speedDirection *= -1;
      updateDirectionButton();
      updateSpeedDisplayAndButtons(); // Update speed display too
    }
    function updateSpeedDisplayAndButtons() {
      const currentPreset = speedPresets[currentSpeedIndex];
      const directionLabel = speedDirection < 0 ? ' (Reverse)' : ''; // Add label for reverse
      speedDisplay.textContent = `Speed: ${currentPreset.label}${directionLabel}`;
      speedDownBtn.disabled = currentSpeedIndex === 0;
      speedUpBtn.disabled = currentSpeedIndex === speedPresets.length - 1;
    }

    playPauseBtn.addEventListener('click', togglePlayPause);
    reverseBtn.addEventListener('click', toggleDirection); // Add listener for reverse button
    speedUpBtn.addEventListener('click', () => { currentSpeedIndex = min(speedPresets.length - 1, currentSpeedIndex + 1); updateSpeedDisplayAndButtons(); });
    speedDownBtn.addEventListener('click', () => { currentSpeedIndex = max(0, currentSpeedIndex - 1); updateSpeedDisplayAndButtons(); });
    resetSpeedBtn.addEventListener('click', () => {
      currentSpeedIndex = defaultSpeedIndex;
      speedDirection = 1; // Also reset direction
      updateSpeedDisplayAndButtons();
      updateDirectionButton(); // Update direction button text
    });

    // ---- LABEL SHOW/HIDE TOGGLE ----
    let labelsVisible = true;

    labelToggleBtn.onclick = function () {
      labelsVisible = !labelsVisible;
      [nakshatraGroup, zodiacGroup].forEach(group => {
        group.children.forEach(child => {
          if (child.type === "Sprite") {
            child.visible = labelsVisible;
          }
        });
      });
      labelToggleBtn.textContent = labelsVisible ? "Hide Labels" : "Show Labels";
    };

    function handleKeyDown(event) { if (event.code === 'Space') { event.preventDefault(); togglePlayPause(); } }
    window.addEventListener('keydown', handleKeyDown);

    // Initial UI setup
    playPauseBtn.textContent = animateFlag ? 'Pause' : 'Play';
    console.log("Initial button text set to:", playPauseBtn.textContent);
    updateDirectionButton();
    updateSpeedDisplayAndButtons();

    // --- Position Control Functions ---
    // Convert degrees to radians
    function degreesToRadians(degrees) {
      return degrees * (PI / 180);
    }

    // Convert radians to degrees
    function radiansToDegrees(radians) {
      // Normalize to 0-2π range
      const normalizedRadians = radians % (2 * PI);
      const positiveRadians = normalizedRadians < 0 ? normalizedRadians + 2 * PI : normalizedRadians;
      return positiveRadians * (180 / PI);
    }

    // Format degrees as degrees, minutes, seconds
    function formatDegrees(degrees) {
      const totalSeconds = degrees * 3600;
      const degreesInt = Math.floor(degrees);
      const minutesFloat = (degrees - degreesInt) * 60;
      const minutesInt = Math.floor(minutesFloat);
      const secondsInt = Math.floor((minutesFloat - minutesInt) * 60);
      return `${degreesInt}° ${minutesInt}' ${secondsInt}"`;
    }

    // Formated degree in sinhala rashi names
    function formatDegreesSinhala(degrees) {
      const totalSeconds = degrees * 3600;
      const degreesInt = Math.floor(degrees);
      const minutesFloat = (degrees - degreesInt) * 60;
      const minutesInt = Math.floor(minutesFloat);
      const secondsInt = Math.floor((minutesFloat - minutesInt) * 60);
      const rashiIndex = Math.floor(degreesInt / 30);
      const rashiNames = ['මේෂ', 'වෘෂභ', 'මිථුන', 'කටක', 'සිංහ', 'කන්‍යා', 'තුලා', 'වෘෂ්චික', 'ධනු', 'මකර', 'කුම්භ', 'මීන'];
      const rashiName = rashiNames[rashiIndex];
      const rashiRemainingDegrees = degreesInt % 30;
      return `${rashiName} ${rashiRemainingDegrees}° ${minutesInt}' ${secondsInt}"`;
    }

    // --- MOON PHASE CALCULATION AND DISPLAY FUNCTION ---
    function updateMoonPhaseDisplay(currentSunAngle, currentMoonAngle) {
      if (!moonPhaseNameElement) return; // Safety check

      let elongation = (currentMoonAngle - currentSunAngle);
      // Normalize elongation to 0-2PI
      elongation = (elongation % (2 * PI) + 2 * PI) % (2 * PI);
      const elongationDegrees = elongation * (180 / PI); // Convert to degrees 0-360

      // Determine phase index (0-29 for 30 phases)
      // Each phase covers 360/30 = 12 degrees.
      const degreesPerPhase = 360 / 30;
      let phaseIndex = Math.floor(elongationDegrees / degreesPerPhase);

      // Ensure phaseIndex is within bounds (0 to 29)
      // Math.floor(360 / 12) = 30. If elongation is exactly 360 (or 2*PI), it should be phase 0.
      phaseIndex = phaseIndex % 30;

      moonPhaseNameElement.textContent = moonPhaseNames[phaseIndex];
    }

    // Update position displays
    function updatePositionDisplays() {
      // Get current angles
      let sunAngle, moonAngle;

      sunAngle = getSunAngle();
      moonAngle = getMoonAngle();

      // Convert to degrees and format
      const sunDegrees = radiansToDegrees(sunAngle);
      const moonDegrees = radiansToDegrees(moonAngle);

      sunPositionDisplay.textContent = formatDegrees(sunDegrees);
      moonPositionDisplay.textContent = formatDegrees(moonDegrees);

      sunPositionText.textContent = formatDegreesSinhala(sunDegrees);
      moonPositionText.textContent = formatDegreesSinhala(moonDegrees);

      // Update sliders if not being dragged
      if (!isManualPositionActive) {
        $("#sunKnob").val(sunDegrees).trigger('change');
        $("#moonKnob").val(moonDegrees).trigger('change');
      }
      updateMoonPhaseDisplay(sunAngle, moonAngle); // Update moon phase
    }

    playPauseBtn.addEventListener('click', function () {
      // Get the current button text to determine the current state
      const currentButtonText = playPauseBtn.textContent;
      console.log("Play/Pause button clicked. Current button text:", currentButtonText);

      if (currentButtonText === "Pause") {
        // Button says "Pause", so we're currently running and want to pause
        console.log("Pausing animation");
        animateFlag = false;
        playPauseBtn.textContent = "Play";
      } else {
        // Button says "Play", so we're currently paused and want to resume
        console.log("Resuming animation");

        animateFlag = true;
        playPauseBtn.textContent = "Pause";
      }

      console.log("New animation state:", animateFlag ? "RUNNING" : "PAUSED");
    });

    // --- Mouse Wheel Zoom ---
    function handleMouseWheel(event) {
      event.preventDefault(); // Prevent default page scrolling

      const zoomIntensity = 0.05; // How much to zoom per scroll tick
      const delta = event.deltaY;

      let zoomFactor;
      if (delta < 0) { // Scrolling up -> Zoom In
        zoomFactor = 1 - zoomIntensity;
      } else { // Scrolling down -> Zoom Out
        zoomFactor = 1 + zoomIntensity;
      }

      // Adjust camera Y position, clamping within limits
      camera.position.y = max(minCameraY, min(maxCameraY, camera.position.y * zoomFactor));

      // No need for updateProjectionMatrix() when changing position
      camera.lookAt(0, 0, 0); // Ensure camera still looks at the center
    }
    renderer.domElement.addEventListener('wheel', handleMouseWheel, { passive: false }); // Add wheel listener to canvas

    function currentMoonPosition() {
      return (simulationTime / moonPeriodDays) * 2 * PI;
    }

    function currentSunPosition() {
      return (simulationTime / sunPeriodDays) * 2 * PI;
    }

    function getMoonAngle() {
      return currentMoonPosition() + manualMoonAdjustment;
    }

    function getSunAngle() {
      return currentSunPosition() + manualSunAjustment;
    }


    // --- Utility Functions ---

    // Existing function for Sprites (used for Nakshatras)
    function createTextSprite(message, fontSize = 30, color = '#ffffff') {
      const effectiveScale = window.devicePixelRatio || 1;
      const padding = 10 * (fontSize / 30);
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = `bold ${fontSize}px sans-serif`;
      const textMetrics = ctx.measureText(message);
      const textWidth = textMetrics.width;
      canvas.width = (textWidth + padding * 2) * effectiveScale;
      canvas.height = (fontSize + padding * 2) * effectiveScale;
      ctx.scale(effectiveScale, effectiveScale);
      ctx.font = `bold ${fontSize}px sans-serif`;
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      ctx.shadowBlur = 3 * effectiveScale;
      ctx.shadowOffsetX = 1 * effectiveScale;
      ctx.shadowOffsetY = 1 * effectiveScale;
      ctx.fillText(message, (textWidth + padding * 2) / 2, (fontSize + padding * 2) / 2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      // Use SpriteMaterial for Sprites
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true, alphaTest: 0.1, depthTest: false, sizeAttenuation: true });
      const sprite = new THREE.Sprite(material);
      const spriteScaleFactor = 0.05; // Adjust this factor as needed
      const spriteWidth = canvas.width / effectiveScale * spriteScaleFactor * (fontSize / 30);
      const spriteHeight = canvas.height / effectiveScale * spriteScaleFactor * (fontSize / 30);
      sprite.scale.set(spriteWidth, spriteHeight, 1);
      return sprite;
    }

    // =========================
    // === MINI MOON PHASE 3D VIEW ===
    // =========================

    // (Add a <canvas id="moon-phase-3d" width="170" height="170"></canvas> in your #moon-phase-container)

    // 1. Setup mini Three.js scene for the 3D moon phase
    const moonPhase3dCanvas = document.getElementById('moon-phase-3d');
    const moonPhase3dRenderer = new THREE.WebGLRenderer({
      canvas: moonPhase3dCanvas,
      alpha: true,
      antialias: true,
    });
    moonPhase3dRenderer.setClearColor(0x000000, 0);

    const moon3dScene = new THREE.Scene();
    const moon3dCamera = new THREE.PerspectiveCamera(24, 1, 0.1, 10);
    moon3dCamera.position.set(0, 0, 3);
    moon3dCamera.lookAt(0, 0, 0);

    // Use the same moonMaterial for fidelity
    const moon3d = new THREE.Mesh(
      new THREE.SphereGeometry(1, 64, 64),
      moonMaterial
    );
    moon3dScene.add(moon3d);

    const moon3dLight = new THREE.DirectionalLight(0xffffff, 2.2);
    moon3dScene.add(moon3dLight);
    moon3dScene.add(new THREE.AmbientLight(0x303040, 0.7));

    // ==============================
    // ========== ANIMATION =========
    // ==============================

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (animateFlag) {
        const currentSpeedValue = speedPresets[currentSpeedIndex].value;
        const simulationDaysElapsed = delta * currentSpeedValue * speedDirection;
        simulationTime += simulationDaysElapsed;

        const moonAngle = 2 * PI - getMoonAngle();
        const sunAngle = 2 * PI - getSunAngle();

        moon.position.set(moonOrbitRadius * cos(moonAngle), 0, moonOrbitRadius * sin(moonAngle));
        sun.position.set(sunOrbitRadius * cos(sunAngle), 0, sunOrbitRadius * sin(sunAngle));
        sunLight.position.copy(sun.position);

        updatePositionDisplays();
        earth.rotation.y += earthRadiansPerDay * simulationDaysElapsed;
        // since moon always faces the earth, we have to rotate it same angle 
        moon.rotation.y = -moonAngle;
      }

      // --- 3D Moon Mini Phase View Update ---
      // Camera is positioned as if you are at the earth, looking at the moon
      const miniMoonAngle = 2 * PI - getMoonAngle();
      const miniSunAngle = 2 * PI - getSunAngle();

      // Camera looks from earth to moon
      const camDistance = 6;
      const camX = Math.cos(miniMoonAngle) * camDistance;
      const camZ = Math.sin(miniMoonAngle) * camDistance;
      moon3dCamera.position.set(camX, 0, camZ);
      moon3dCamera.up.set(0, 1, 0);
      moon3dCamera.lookAt(0, 0, 0);

      // Sunlight illuminates from sun's direction
      const sunX = Math.cos(miniSunAngle) * camDistance * -  1;
      const sunZ = Math.sin(miniSunAngle) * camDistance * - 1;
      moon3dLight.position.set(sunX, 0, sunZ);
      moon3dLight.target.position.set(0, 0, 0);
      moon3dLight.target.updateMatrixWorld();

      // (Optional: If you want to keep north-up, set .rotation.y = 0)
      moon3d.rotation.y = -miniMoonAngle;

      moonPhase3dRenderer.render(moon3dScene, moon3dCamera);

      // --- Main scene render ---
      renderer.render(scene, camera);
    }


    // ... [keep all your other utility, controls, UI, etc. code here] ...

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      updateCameraPosition();
    }, false);

    animate();
    updatePositionDisplays();
  </script>
  <script>
    $(function () {
      // SUN
      $("#sunKnob").knob({
        min: 0,
        max: 360,
        step: 1,
        angleArc: 360,
        angleOffset: 0,
        width: 54,
        height: 54,
        fgColor: "#ffcc66",
        bgColor: "#232344",
        thickness: 0.32,
        displayInput: false,
        change: function (deg) {
          manualSunPosition = deg;
          lastAdjustedObject = 'sun';
          const sunAngle = degreesToRadians(manualSunPosition);
          sun.position.set(sunOrbitRadius * Math.cos(2 * Math.PI - sunAngle), 0, sunOrbitRadius * Math.sin(2 * Math.PI - sunAngle));
          sunLight.position.copy(sun.position);
          updatePositionDisplays();
          if (animateFlag) {
            animateFlag = false;
            updatePlayPauseButton();
          }
          manualSunAjustment = sunAngle - currentSunPosition();
          if (manualSunAjustment < 0) {
            manualSunAjustment += Math.PI * 2;
          }
        }
      });

      // MOON
      $("#moonKnob").knob({
        min: 0,
        max: 360,
        step: 1,
        angleArc: 360,
        angleOffset: 0,
        width: 54,
        height: 54,
        fgColor: "#aaccff",
        bgColor: "#232344",
        thickness: 0.32,
        displayInput: false,
        change: function (deg) {
          manualMoonPosition = deg;
          lastAdjustedObject = 'moon';
          const moonAngle = degreesToRadians(manualMoonPosition);
          moon.position.set(moonOrbitRadius * Math.cos(2 * Math.PI - moonAngle), 0, moonOrbitRadius * Math.sin(2 * Math.PI - moonAngle));
          updatePositionDisplays();
          if (animateFlag) {
            animateFlag = false;
            updatePlayPauseButton();
          }
          manualMoonAdjustment = moonAngle - currentMoonPosition();
          if (manualMoonAdjustment < 0) {
            manualMoonAdjustment += Math.PI * 2;
          }
        }
      });

      // OPTIONAL: Update knob value if you update sun/moon by code (sync knobs)
      function syncKnobsToPositions() {
        $("#sunKnob").val(manualSunPosition ?? 0).trigger('change');
        $("#moonKnob").val(manualMoonPosition ?? 0).trigger('change');
      }
    });

  </script>

</body>

</html>